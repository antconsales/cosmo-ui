import type { Tooltip } from "@cosmo/core-schema";
import { TOOLTIP_CONSTRAINTS } from "@cosmo/core-schema";
import type { ValidationError, ValidationResult } from "./types";

/**
 * TooltipValidator
 * Validates and sanitizes Tooltip schemas generated by AI
 */
export class TooltipValidator {
  validate(tooltip: Tooltip): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationError[] = [];

    // === REQUIRED FIELDS ===
    if (!tooltip.id || tooltip.id.trim() === "") {
      errors.push({
        field: "id",
        message: "id is required and cannot be empty",
        severity: "error",
      });
    }

    if (!tooltip.content || tooltip.content.trim() === "") {
      errors.push({
        field: "content",
        message: "content is required and cannot be empty",
        severity: "error",
      });
    }

    // === CONTENT CONSTRAINTS ===
    if (tooltip.content && tooltip.content.length > TOOLTIP_CONSTRAINTS.content.maxLength) {
      errors.push({
        field: "content",
        message: `content exceeds max length of ${TOOLTIP_CONSTRAINTS.content.maxLength} chars`,
        severity: "error",
      });
    }

    // === POSITION VALIDATION ===
    const validPositions = ["top", "bottom", "left", "right", "top-left", "top-right", "bottom-left", "bottom-right"];
    if (tooltip.position && !validPositions.includes(tooltip.position)) {
      errors.push({
        field: "position",
        message: `position must be one of: ${validPositions.join(", ")}`,
        severity: "error",
      });
    }

    // === TRIGGER VALIDATION ===
    const validTriggers = ["hover", "click", "focus", "manual"];
    if (tooltip.trigger && !validTriggers.includes(tooltip.trigger)) {
      errors.push({
        field: "trigger",
        message: `trigger must be one of: ${validTriggers.join(", ")}`,
        severity: "error",
      });
    }

    // === VARIANT VALIDATION ===
    const validVariants = ["dark", "light", "info", "warning", "error"];
    if (tooltip.variant && !validVariants.includes(tooltip.variant)) {
      errors.push({
        field: "variant",
        message: `variant must be one of: ${validVariants.join(", ")}`,
        severity: "error",
      });
    }

    // === MAX WIDTH CONSTRAINTS ===
    if (tooltip.maxWidth !== undefined) {
      if (typeof tooltip.maxWidth !== "number") {
        errors.push({
          field: "maxWidth",
          message: "maxWidth must be a number",
          severity: "error",
        });
      } else if (tooltip.maxWidth < TOOLTIP_CONSTRAINTS.maxWidth.min || tooltip.maxWidth > TOOLTIP_CONSTRAINTS.maxWidth.max) {
        warnings.push({
          field: "maxWidth",
          message: `maxWidth should be between ${TOOLTIP_CONSTRAINTS.maxWidth.min}-${TOOLTIP_CONSTRAINTS.maxWidth.max}px`,
          severity: "warning",
        });
      }
    }

    // === DELAY CONSTRAINTS ===
    if (tooltip.delayShow !== undefined) {
      if (typeof tooltip.delayShow !== "number" || tooltip.delayShow < TOOLTIP_CONSTRAINTS.delay.min) {
        warnings.push({
          field: "delayShow",
          message: `delayShow should be >= ${TOOLTIP_CONSTRAINTS.delay.min}ms`,
          severity: "warning",
        });
      }
    }

    if (tooltip.delayHide !== undefined) {
      if (typeof tooltip.delayHide !== "number" || tooltip.delayHide < TOOLTIP_CONSTRAINTS.delay.min) {
        warnings.push({
          field: "delayHide",
          message: `delayHide should be >= ${TOOLTIP_CONSTRAINTS.delay.min}ms`,
          severity: "warning",
        });
      }
    }

    // === METADATA VALIDATION ===
    if (tooltip.metadata) {
      const { anchorType, worldPosition, autoAnchor, autoAnchorDistance } = tooltip.metadata;

      if (anchorType && anchorType !== "screen-space" && anchorType !== "world-space") {
        errors.push({
          field: "metadata.anchorType",
          message: 'anchorType must be "screen-space" or "world-space"',
          severity: "error",
        });
      }

      if (worldPosition !== undefined) {
        if (
          !Array.isArray(worldPosition) ||
          worldPosition.length !== 3 ||
          !worldPosition.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldPosition",
            message: "worldPosition must be [x, y, z] array of 3 numbers",
            severity: "error",
          });
        }
      }

      if (autoAnchor !== undefined) {
        if (autoAnchor !== "face" && autoAnchor !== "surface" && autoAnchor !== "gaze") {
          errors.push({
            field: "metadata.autoAnchor",
            message: 'autoAnchor must be "face", "surface", or "gaze"',
            severity: "error",
          });
        }
      }

      if (autoAnchorDistance !== undefined) {
        if (typeof autoAnchorDistance !== "number" || autoAnchorDistance <= 0) {
          errors.push({
            field: "metadata.autoAnchorDistance",
            message: "autoAnchorDistance must be a positive number",
            severity: "error",
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Sanitize a Tooltip, applying defaults and constraints
   */
  sanitize(tooltip: Partial<Tooltip>): Tooltip {
    let maxWidth = tooltip.maxWidth ?? TOOLTIP_CONSTRAINTS.maxWidth.default;
    maxWidth = Math.max(TOOLTIP_CONSTRAINTS.maxWidth.min, Math.min(TOOLTIP_CONSTRAINTS.maxWidth.max, maxWidth));

    return {
      id: tooltip.id || `tooltip-${Date.now()}`,
      content: (tooltip.content || "").slice(0, TOOLTIP_CONSTRAINTS.content.maxLength),
      position: tooltip.position || "top",
      trigger: tooltip.trigger || "hover",
      variant: tooltip.variant || "dark",
      showArrow: tooltip.showArrow ?? true,
      delayShow: Math.max(TOOLTIP_CONSTRAINTS.delay.min, tooltip.delayShow ?? TOOLTIP_CONSTRAINTS.delay.default),
      delayHide: Math.max(TOOLTIP_CONSTRAINTS.delay.min, tooltip.delayHide ?? 0),
      maxWidth,
      visible: tooltip.visible,
      targetSelector: tooltip.targetSelector,
      metadata: tooltip.metadata,
    };
  }
}
