import type { ContextBadge } from "@cosmo/core-schema";
import { CONTEXTBADGE_CONSTRAINTS } from "@cosmo/core-schema";
import type { ValidationError, ValidationResult } from "./types";

/**
 * ContextBadgeValidator
 * Validates and sanitizes ContextBadge schemas generated by AI
 */
export class ContextBadgeValidator {
  validate(badge: ContextBadge): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationError[] = [];

    // === REQUIRED FIELDS ===
    if (!badge.id || badge.id.trim() === "") {
      errors.push({
        field: "id",
        message: "id is required and cannot be empty",
        severity: "error",
      });
    }

    if (!badge.label || badge.label.trim() === "") {
      errors.push({
        field: "label",
        message: "label is required and cannot be empty",
        severity: "error",
      });
    }

    // === LENGTH CONSTRAINTS ===
    if (badge.label && badge.label.length > CONTEXTBADGE_CONSTRAINTS.label.maxLength) {
      errors.push({
        field: "label",
        message: `label exceeds max length of ${CONTEXTBADGE_CONSTRAINTS.label.maxLength} chars`,
        severity: "error",
      });
    }

    // === VARIANT VALIDATION ===
    const validVariants = ["neutral", "info", "success", "warning", "error"];
    if (badge.variant && !validVariants.includes(badge.variant)) {
      errors.push({
        field: "variant",
        message: `variant must be one of: ${validVariants.join(", ")}`,
        severity: "error",
      });
    }

    // === ICON VALIDATION ===
    const validIcons = ["none", "info", "check", "alert", "error", "bell", "clock", "star", "user", "wifi", "battery"];
    if (badge.icon && !validIcons.includes(badge.icon)) {
      errors.push({
        field: "icon",
        message: `icon must be one of: ${validIcons.join(", ")}`,
        severity: "error",
      });
    }

    // === POSITION VALIDATION ===
    const validPositions = [
      "top-left", "top-center", "top-right",
      "center-left", "center-right",
      "bottom-left", "bottom-center", "bottom-right"
    ];
    if (badge.position && !validPositions.includes(badge.position)) {
      errors.push({
        field: "position",
        message: `position must be one of: ${validPositions.join(", ")}`,
        severity: "error",
      });
    }

    // === CONTEXTUAL COLOR VALIDATION ===
    if (badge.contextualColor) {
      if (!CONTEXTBADGE_CONSTRAINTS.contextualColor.pattern.test(badge.contextualColor)) {
        errors.push({
          field: "contextualColor",
          message: "contextualColor must be a valid hex color (e.g., #ff5500)",
          severity: "error",
        });
      }
    }

    // === AUTO-DISMISS CONSTRAINTS ===
    if (badge.autoDismissMs !== null && badge.autoDismissMs !== undefined) {
      if (
        badge.autoDismissMs < CONTEXTBADGE_CONSTRAINTS.autoDismiss.min ||
        badge.autoDismissMs > CONTEXTBADGE_CONSTRAINTS.autoDismiss.max
      ) {
        warnings.push({
          field: "autoDismissMs",
          message: `autoDismissMs should be between ${CONTEXTBADGE_CONSTRAINTS.autoDismiss.min}-${CONTEXTBADGE_CONSTRAINTS.autoDismiss.max}ms`,
          severity: "warning",
        });
      }
    }

    // === METADATA VALIDATION (AR ANCHORING) ===
    if (badge.metadata) {
      const { anchorType, worldPosition, worldRotation, autoAnchor, autoAnchorDistance } = badge.metadata;

      // Validate anchorType
      if (anchorType && anchorType !== "screen-space" && anchorType !== "world-space") {
        errors.push({
          field: "metadata.anchorType",
          message: 'anchorType must be "screen-space" or "world-space"',
          severity: "error",
        });
      }

      // Validate worldPosition
      if (worldPosition !== undefined) {
        if (
          !Array.isArray(worldPosition) ||
          worldPosition.length !== 3 ||
          !worldPosition.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldPosition",
            message: "worldPosition must be [x, y, z] array of 3 numbers",
            severity: "error",
          });
        }

        // Warning if worldPosition provided but anchorType is screen-space
        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.worldPosition",
            message: "worldPosition ignored when anchorType is screen-space",
            severity: "warning",
          });
        }
      }

      // Validate worldRotation
      if (worldRotation !== undefined) {
        if (
          !Array.isArray(worldRotation) ||
          worldRotation.length !== 3 ||
          !worldRotation.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldRotation",
            message: "worldRotation must be [x, y, z] array of 3 numbers (radians)",
            severity: "error",
          });
        }

        // Warning if worldRotation provided but anchorType is screen-space
        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.worldRotation",
            message: "worldRotation ignored when anchorType is screen-space",
            severity: "warning",
          });
        }
      }

      // Validate autoAnchor
      if (autoAnchor !== undefined) {
        if (autoAnchor !== "face" && autoAnchor !== "surface" && autoAnchor !== "gaze") {
          errors.push({
            field: "metadata.autoAnchor",
            message: 'autoAnchor must be "face", "surface", or "gaze"',
            severity: "error",
          });
        }

        // Warning if autoAnchor used with screen-space
        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.autoAnchor",
            message: "autoAnchor ignored when anchorType is screen-space",
            severity: "warning",
          });
        }

        // Warning if both autoAnchor and explicit worldPosition
        if (worldPosition) {
          warnings.push({
            field: "metadata.autoAnchor",
            message: "autoAnchor overrides worldPosition",
            severity: "warning",
          });
        }
      }

      // Validate autoAnchorDistance
      if (autoAnchorDistance !== undefined) {
        if (typeof autoAnchorDistance !== "number" || autoAnchorDistance <= 0) {
          errors.push({
            field: "metadata.autoAnchorDistance",
            message: "autoAnchorDistance must be a positive number (meters)",
            severity: "error",
          });
        }
      }

      // Validate followTarget
      if (badge.metadata.followTarget !== undefined) {
        if (typeof badge.metadata.followTarget !== "string" || badge.metadata.followTarget.trim() === "") {
          errors.push({
            field: "metadata.followTarget",
            message: "followTarget must be a non-empty string (CSS selector or anchor ID)",
            severity: "error",
          });
        }
      }

      // Warning if world-space but no position specified
      if (anchorType === "world-space" && !worldPosition && !autoAnchor) {
        warnings.push({
          field: "metadata",
          message: "world-space badge should have worldPosition or autoAnchor",
          severity: "warning",
        });
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validates and sanitizes a badge
   * Applies safe defaults and corrections
   */
  sanitize(badge: Partial<ContextBadge>): ContextBadge {
    const sanitized: ContextBadge = {
      id: badge.id || `badge-${Date.now()}`,
      label: (badge.label || "Badge").slice(0, CONTEXTBADGE_CONSTRAINTS.label.maxLength),
      variant: badge.variant || "neutral",
      icon: badge.icon || "none",
      position: badge.position || "top-right",
      contextualColor: badge.contextualColor,
      autoDismissMs: badge.autoDismissMs ?? null,
      dismissible: badge.dismissible ?? true,
      pulse: badge.pulse ?? false,
      metadata: badge.metadata,
    };

    // Validate contextualColor format, remove if invalid
    if (sanitized.contextualColor && !CONTEXTBADGE_CONSTRAINTS.contextualColor.pattern.test(sanitized.contextualColor)) {
      sanitized.contextualColor = undefined;
    }

    // Clamp autoDismissMs to valid range
    if (sanitized.autoDismissMs !== null && sanitized.autoDismissMs !== undefined) {
      sanitized.autoDismissMs = Math.max(
        CONTEXTBADGE_CONSTRAINTS.autoDismiss.min,
        Math.min(CONTEXTBADGE_CONSTRAINTS.autoDismiss.max, sanitized.autoDismissMs)
      );
    }

    return sanitized;
  }
}
