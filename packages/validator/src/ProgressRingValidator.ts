import type { ProgressRing } from "@cosmo/core-schema";
import { PROGRESSRING_CONSTRAINTS } from "@cosmo/core-schema";
import type { ValidationError, ValidationResult } from "./types";

/**
 * ProgressRingValidator
 * Validates and sanitizes ProgressRing schemas generated by AI
 */
export class ProgressRingValidator {
  validate(ring: ProgressRing): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationError[] = [];

    // === REQUIRED FIELDS ===
    if (!ring.id || ring.id.trim() === "") {
      errors.push({
        field: "id",
        message: "id is required and cannot be empty",
        severity: "error",
      });
    }

    if (ring.value === undefined || ring.value === null) {
      errors.push({
        field: "value",
        message: "value is required",
        severity: "error",
      });
    }

    // === VALUE CONSTRAINTS ===
    if (typeof ring.value === "number") {
      if (ring.value < PROGRESSRING_CONSTRAINTS.value.min) {
        warnings.push({
          field: "value",
          message: `value ${ring.value} below minimum ${PROGRESSRING_CONSTRAINTS.value.min}, will be clamped`,
          severity: "warning",
        });
      }
      if (ring.value > PROGRESSRING_CONSTRAINTS.value.max) {
        warnings.push({
          field: "value",
          message: `value ${ring.value} exceeds maximum ${PROGRESSRING_CONSTRAINTS.value.max}, will be clamped`,
          severity: "warning",
        });
      }
    } else if (ring.value !== undefined) {
      errors.push({
        field: "value",
        message: "value must be a number",
        severity: "error",
      });
    }

    // === SIZE CONSTRAINTS ===
    if (ring.size !== undefined) {
      if (typeof ring.size !== "number") {
        errors.push({
          field: "size",
          message: "size must be a number",
          severity: "error",
        });
      } else if (ring.size < PROGRESSRING_CONSTRAINTS.size.min || ring.size > PROGRESSRING_CONSTRAINTS.size.max) {
        warnings.push({
          field: "size",
          message: `size should be between ${PROGRESSRING_CONSTRAINTS.size.min}-${PROGRESSRING_CONSTRAINTS.size.max}`,
          severity: "warning",
        });
      }
    }

    // === THICKNESS CONSTRAINTS ===
    if (ring.thickness !== undefined) {
      if (typeof ring.thickness !== "number") {
        errors.push({
          field: "thickness",
          message: "thickness must be a number",
          severity: "error",
        });
      } else if (ring.thickness < PROGRESSRING_CONSTRAINTS.thickness.min || ring.thickness > PROGRESSRING_CONSTRAINTS.thickness.max) {
        warnings.push({
          field: "thickness",
          message: `thickness should be between ${PROGRESSRING_CONSTRAINTS.thickness.min}-${PROGRESSRING_CONSTRAINTS.thickness.max}`,
          severity: "warning",
        });
      }
    }

    // === VARIANT VALIDATION ===
    const validVariants = ["neutral", "info", "success", "warning", "error"];
    if (ring.variant && !validVariants.includes(ring.variant)) {
      errors.push({
        field: "variant",
        message: `variant must be one of: ${validVariants.join(", ")}`,
        severity: "error",
      });
    }

    // === POSITION VALIDATION ===
    const validPositions = [
      "top-left", "top-center", "top-right",
      "center-left", "center", "center-right",
      "bottom-left", "bottom-center", "bottom-right"
    ];
    if (ring.position && !validPositions.includes(ring.position)) {
      errors.push({
        field: "position",
        message: `position must be one of: ${validPositions.join(", ")}`,
        severity: "error",
      });
    }

    // === LABEL CONSTRAINTS ===
    if (ring.label && ring.label.length > PROGRESSRING_CONSTRAINTS.label.maxLength) {
      errors.push({
        field: "label",
        message: `label exceeds max length of ${PROGRESSRING_CONSTRAINTS.label.maxLength} chars`,
        severity: "error",
      });
    }

    // === METADATA VALIDATION (AR ANCHORING) ===
    if (ring.metadata) {
      const { anchorType, worldPosition, worldRotation, autoAnchor, autoAnchorDistance } = ring.metadata;

      // Validate anchorType
      if (anchorType && anchorType !== "screen-space" && anchorType !== "world-space") {
        errors.push({
          field: "metadata.anchorType",
          message: 'anchorType must be "screen-space" or "world-space"',
          severity: "error",
        });
      }

      // Validate worldPosition
      if (worldPosition !== undefined) {
        if (
          !Array.isArray(worldPosition) ||
          worldPosition.length !== 3 ||
          !worldPosition.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldPosition",
            message: "worldPosition must be [x, y, z] array of 3 numbers",
            severity: "error",
          });
        }

        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.worldPosition",
            message: "worldPosition ignored when anchorType is screen-space",
            severity: "warning",
          });
        }
      }

      // Validate worldRotation
      if (worldRotation !== undefined) {
        if (
          !Array.isArray(worldRotation) ||
          worldRotation.length !== 3 ||
          !worldRotation.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldRotation",
            message: "worldRotation must be [x, y, z] array of 3 numbers (radians)",
            severity: "error",
          });
        }

        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.worldRotation",
            message: "worldRotation ignored when anchorType is screen-space",
            severity: "warning",
          });
        }
      }

      // Validate autoAnchor
      if (autoAnchor !== undefined) {
        if (autoAnchor !== "face" && autoAnchor !== "surface" && autoAnchor !== "gaze") {
          errors.push({
            field: "metadata.autoAnchor",
            message: 'autoAnchor must be "face", "surface", or "gaze"',
            severity: "error",
          });
        }

        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.autoAnchor",
            message: "autoAnchor ignored when anchorType is screen-space",
            severity: "warning",
          });
        }

        if (worldPosition) {
          warnings.push({
            field: "metadata.autoAnchor",
            message: "autoAnchor overrides worldPosition",
            severity: "warning",
          });
        }
      }

      // Validate autoAnchorDistance
      if (autoAnchorDistance !== undefined) {
        if (typeof autoAnchorDistance !== "number" || autoAnchorDistance <= 0) {
          errors.push({
            field: "metadata.autoAnchorDistance",
            message: "autoAnchorDistance must be a positive number (meters)",
            severity: "error",
          });
        }
      }

      // Warning if world-space but no position specified
      if (anchorType === "world-space" && !worldPosition && !autoAnchor) {
        warnings.push({
          field: "metadata",
          message: "world-space ring should have worldPosition or autoAnchor",
          severity: "warning",
        });
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validates and sanitizes a ring
   * Applies safe defaults and corrections
   */
  sanitize(ring: Partial<ProgressRing>): ProgressRing {
    // Clamp value to valid range
    let value = ring.value ?? 0;
    value = Math.max(PROGRESSRING_CONSTRAINTS.value.min, Math.min(PROGRESSRING_CONSTRAINTS.value.max, value));

    // Clamp size to valid range
    let size = ring.size ?? PROGRESSRING_CONSTRAINTS.size.default;
    size = Math.max(PROGRESSRING_CONSTRAINTS.size.min, Math.min(PROGRESSRING_CONSTRAINTS.size.max, size));

    // Clamp thickness to valid range
    let thickness = ring.thickness ?? PROGRESSRING_CONSTRAINTS.thickness.default;
    thickness = Math.max(PROGRESSRING_CONSTRAINTS.thickness.min, Math.min(PROGRESSRING_CONSTRAINTS.thickness.max, thickness));

    const sanitized: ProgressRing = {
      id: ring.id || `ring-${Date.now()}`,
      value,
      size,
      thickness,
      variant: ring.variant || "neutral",
      animated: ring.animated ?? true,
      showValue: ring.showValue ?? false,
      label: ring.label?.slice(0, PROGRESSRING_CONSTRAINTS.label.maxLength),
      position: ring.position || "center",
      metadata: ring.metadata,
    };

    return sanitized;
  }
}
