import type { StatusIndicator } from "@cosmo/core-schema";
import { STATUSINDICATOR_CONSTRAINTS } from "@cosmo/core-schema";
import type { ValidationError, ValidationResult } from "./types";

/**
 * StatusIndicatorValidator
 * Validates and sanitizes StatusIndicator schemas generated by AI
 */
export class StatusIndicatorValidator {
  validate(indicator: StatusIndicator): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationError[] = [];

    // === REQUIRED FIELDS ===
    if (!indicator.id || indicator.id.trim() === "") {
      errors.push({
        field: "id",
        message: "id is required and cannot be empty",
        severity: "error",
      });
    }

    if (!indicator.state) {
      errors.push({
        field: "state",
        message: "state is required",
        severity: "error",
      });
    }

    // === STATE VALIDATION ===
    const validStates = ["idle", "active", "loading", "success", "warning", "error"];
    if (indicator.state && !validStates.includes(indicator.state)) {
      errors.push({
        field: "state",
        message: `state must be one of: ${validStates.join(", ")}`,
        severity: "error",
      });
    }

    // === SIZE CONSTRAINTS ===
    if (indicator.size !== undefined) {
      if (typeof indicator.size !== "number") {
        errors.push({
          field: "size",
          message: "size must be a number",
          severity: "error",
        });
      } else if (indicator.size < STATUSINDICATOR_CONSTRAINTS.size.min || indicator.size > STATUSINDICATOR_CONSTRAINTS.size.max) {
        warnings.push({
          field: "size",
          message: `size should be between ${STATUSINDICATOR_CONSTRAINTS.size.min}-${STATUSINDICATOR_CONSTRAINTS.size.max}`,
          severity: "warning",
        });
      }
    }

    // === POSITION VALIDATION ===
    const validPositions = [
      "top-left", "top-center", "top-right",
      "center-left", "center", "center-right",
      "bottom-left", "bottom-center", "bottom-right"
    ];
    if (indicator.position && !validPositions.includes(indicator.position)) {
      errors.push({
        field: "position",
        message: `position must be one of: ${validPositions.join(", ")}`,
        severity: "error",
      });
    }

    // === LABEL CONSTRAINTS ===
    if (indicator.label && indicator.label.length > STATUSINDICATOR_CONSTRAINTS.label.maxLength) {
      errors.push({
        field: "label",
        message: `label exceeds max length of ${STATUSINDICATOR_CONSTRAINTS.label.maxLength} chars`,
        severity: "error",
      });
    }

    // === BOOLEAN FIELDS ===
    if (indicator.pulse !== undefined && typeof indicator.pulse !== "boolean") {
      errors.push({
        field: "pulse",
        message: "pulse must be a boolean",
        severity: "error",
      });
    }

    if (indicator.glow !== undefined && typeof indicator.glow !== "boolean") {
      errors.push({
        field: "glow",
        message: "glow must be a boolean",
        severity: "error",
      });
    }

    // === METADATA VALIDATION (AR ANCHORING) ===
    if (indicator.metadata) {
      const { anchorType, worldPosition, worldRotation, autoAnchor, autoAnchorDistance } = indicator.metadata;

      // Validate anchorType
      if (anchorType && anchorType !== "screen-space" && anchorType !== "world-space") {
        errors.push({
          field: "metadata.anchorType",
          message: 'anchorType must be "screen-space" or "world-space"',
          severity: "error",
        });
      }

      // Validate worldPosition
      if (worldPosition !== undefined) {
        if (
          !Array.isArray(worldPosition) ||
          worldPosition.length !== 3 ||
          !worldPosition.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldPosition",
            message: "worldPosition must be [x, y, z] array of 3 numbers",
            severity: "error",
          });
        }

        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.worldPosition",
            message: "worldPosition ignored when anchorType is screen-space",
            severity: "warning",
          });
        }
      }

      // Validate worldRotation
      if (worldRotation !== undefined) {
        if (
          !Array.isArray(worldRotation) ||
          worldRotation.length !== 3 ||
          !worldRotation.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldRotation",
            message: "worldRotation must be [x, y, z] array of 3 numbers (radians)",
            severity: "error",
          });
        }

        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.worldRotation",
            message: "worldRotation ignored when anchorType is screen-space",
            severity: "warning",
          });
        }
      }

      // Validate autoAnchor
      if (autoAnchor !== undefined) {
        if (autoAnchor !== "face" && autoAnchor !== "surface" && autoAnchor !== "gaze") {
          errors.push({
            field: "metadata.autoAnchor",
            message: 'autoAnchor must be "face", "surface", or "gaze"',
            severity: "error",
          });
        }

        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.autoAnchor",
            message: "autoAnchor ignored when anchorType is screen-space",
            severity: "warning",
          });
        }

        if (worldPosition) {
          warnings.push({
            field: "metadata.autoAnchor",
            message: "autoAnchor overrides worldPosition",
            severity: "warning",
          });
        }
      }

      // Validate autoAnchorDistance
      if (autoAnchorDistance !== undefined) {
        if (typeof autoAnchorDistance !== "number" || autoAnchorDistance <= 0) {
          errors.push({
            field: "metadata.autoAnchorDistance",
            message: "autoAnchorDistance must be a positive number (meters)",
            severity: "error",
          });
        }
      }

      // Warning if world-space but no position specified
      if (anchorType === "world-space" && !worldPosition && !autoAnchor) {
        warnings.push({
          field: "metadata",
          message: "world-space indicator should have worldPosition or autoAnchor",
          severity: "warning",
        });
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validates and sanitizes an indicator
   * Applies safe defaults and corrections
   */
  sanitize(indicator: Partial<StatusIndicator>): StatusIndicator {
    // Clamp size to valid range
    let size = indicator.size ?? STATUSINDICATOR_CONSTRAINTS.size.default;
    size = Math.max(STATUSINDICATOR_CONSTRAINTS.size.min, Math.min(STATUSINDICATOR_CONSTRAINTS.size.max, size));

    // Default pulse behavior: true for loading state
    const pulse = indicator.pulse ?? (indicator.state === "loading");

    const sanitized: StatusIndicator = {
      id: indicator.id || `indicator-${Date.now()}`,
      state: indicator.state || "idle",
      size,
      label: indicator.label?.slice(0, STATUSINDICATOR_CONSTRAINTS.label.maxLength),
      pulse,
      glow: indicator.glow ?? false,
      position: indicator.position || "top-right",
      metadata: indicator.metadata,
    };

    return sanitized;
  }
}
