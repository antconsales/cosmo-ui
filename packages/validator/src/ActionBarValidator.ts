import type { ActionBar } from "@cosmo/core-schema";
import { ACTIONBAR_CONSTRAINTS } from "@cosmo/core-schema";
import type { ValidationError, ValidationResult } from "./types";

/**
 * ActionBarValidator
 * Validates and sanitizes ActionBar schemas generated by AI
 */
export class ActionBarValidator {
  validate(bar: ActionBar): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationError[] = [];

    // === REQUIRED FIELDS ===
    if (!bar.id || bar.id.trim() === "") {
      errors.push({
        field: "id",
        message: "id is required and cannot be empty",
        severity: "error",
      });
    }

    if (!bar.items || !Array.isArray(bar.items)) {
      errors.push({
        field: "items",
        message: "items is required and must be an array",
        severity: "error",
      });
    }

    // === ITEMS CONSTRAINTS ===
    if (bar.items) {
      if (bar.items.length < ACTIONBAR_CONSTRAINTS.items.minCount) {
        errors.push({
          field: "items",
          message: `ActionBar must have at least ${ACTIONBAR_CONSTRAINTS.items.minCount} item`,
          severity: "error",
        });
      }

      if (bar.items.length > ACTIONBAR_CONSTRAINTS.items.maxCount) {
        warnings.push({
          field: "items",
          message: `ActionBar should have max ${ACTIONBAR_CONSTRAINTS.items.maxCount} items for usability`,
          severity: "warning",
        });
      }

      // Validate each item
      bar.items.forEach((item, idx) => {
        if (!item.id || item.id.trim() === "") {
          errors.push({
            field: `items[${idx}].id`,
            message: "Item id is required",
            severity: "error",
          });
        }

        if (!item.icon) {
          errors.push({
            field: `items[${idx}].icon`,
            message: "Item icon is required",
            severity: "error",
          });
        }

        if (!item.label || item.label.trim() === "") {
          errors.push({
            field: `items[${idx}].label`,
            message: "Item label is required for accessibility",
            severity: "error",
          });
        }

        if (item.label && item.label.length > ACTIONBAR_CONSTRAINTS.label.maxLength) {
          warnings.push({
            field: `items[${idx}].label`,
            message: `Label exceeds ${ACTIONBAR_CONSTRAINTS.label.maxLength} chars, may be truncated`,
            severity: "warning",
          });
        }

        if (item.badge !== undefined && item.badge > ACTIONBAR_CONSTRAINTS.badge.max) {
          warnings.push({
            field: `items[${idx}].badge`,
            message: `Badge will display as ${ACTIONBAR_CONSTRAINTS.badge.max}+`,
            severity: "warning",
          });
        }
      });

      // Check for duplicate IDs
      const ids = bar.items.map((item) => item.id);
      const duplicates = ids.filter((id, idx) => ids.indexOf(id) !== idx);
      if (duplicates.length > 0) {
        errors.push({
          field: "items",
          message: `Duplicate item IDs: ${[...new Set(duplicates)].join(", ")}`,
          severity: "error",
        });
      }
    }

    // === POSITION VALIDATION ===
    const validPositions = ["bottom", "top", "left", "right"];
    if (bar.position && !validPositions.includes(bar.position)) {
      errors.push({
        field: "position",
        message: `position must be one of: ${validPositions.join(", ")}`,
        severity: "error",
      });
    }

    // === VARIANT VALIDATION ===
    const validVariants = ["solid", "glass", "minimal"];
    if (bar.variant && !validVariants.includes(bar.variant)) {
      errors.push({
        field: "variant",
        message: `variant must be one of: ${validVariants.join(", ")}`,
        severity: "error",
      });
    }

    // === METADATA VALIDATION ===
    if (bar.metadata) {
      const { anchorType, worldPosition, autoAnchor, autoAnchorDistance } = bar.metadata;

      if (anchorType && anchorType !== "screen-space" && anchorType !== "world-space") {
        errors.push({
          field: "metadata.anchorType",
          message: 'anchorType must be "screen-space" or "world-space"',
          severity: "error",
        });
      }

      if (worldPosition !== undefined) {
        if (
          !Array.isArray(worldPosition) ||
          worldPosition.length !== 3 ||
          !worldPosition.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldPosition",
            message: "worldPosition must be [x, y, z] array of 3 numbers",
            severity: "error",
          });
        }
      }

      if (autoAnchor !== undefined) {
        if (autoAnchor !== "face" && autoAnchor !== "surface" && autoAnchor !== "gaze") {
          errors.push({
            field: "metadata.autoAnchor",
            message: 'autoAnchor must be "face", "surface", or "gaze"',
            severity: "error",
          });
        }
      }

      if (autoAnchorDistance !== undefined) {
        if (typeof autoAnchorDistance !== "number" || autoAnchorDistance <= 0) {
          errors.push({
            field: "metadata.autoAnchorDistance",
            message: "autoAnchorDistance must be a positive number",
            severity: "error",
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Sanitize an ActionBar, applying defaults and constraints
   */
  sanitize(bar: Partial<ActionBar>): ActionBar {
    const items = (bar.items || [])
      .slice(0, ACTIONBAR_CONSTRAINTS.items.maxCount)
      .map((item, idx) => ({
        id: item.id || `item-${idx}`,
        icon: item.icon || "menu",
        label: (item.label || "Action").slice(0, ACTIONBAR_CONSTRAINTS.label.maxLength),
        disabled: item.disabled ?? false,
        active: item.active ?? false,
        badge: item.badge !== undefined ? Math.min(item.badge, ACTIONBAR_CONSTRAINTS.badge.max) : undefined,
      }));

    return {
      id: bar.id || `actionbar-${Date.now()}`,
      items,
      position: bar.position || "bottom",
      variant: bar.variant || "solid",
      showLabels: bar.showLabels ?? false,
      visible: bar.visible ?? true,
      metadata: bar.metadata,
    };
  }
}
