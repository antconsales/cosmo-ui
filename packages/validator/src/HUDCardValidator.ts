import type { HUDCard } from "@cosmo/core-schema";
import { HUDCARD_CONSTRAINTS } from "@cosmo/core-schema";
import type { ValidationError, ValidationResult } from "./types";

/**
 * HUDCardValidator
 * Validates and sanitizes HUDCard schemas generated by AI
 */
export class HUDCardValidator {
  validate(card: HUDCard): ValidationResult {
    const errors: ValidationError[] = [];
    const warnings: ValidationError[] = [];

    // === REQUIRED FIELDS ===
    if (!card.id || card.id.trim() === "") {
      errors.push({
        field: "id",
        message: "id is required and cannot be empty",
        severity: "error",
      });
    }

    if (!card.title || card.title.trim() === "") {
      errors.push({
        field: "title",
        message: "title is required and cannot be empty",
        severity: "error",
      });
    }

    if (!card.content || card.content.trim() === "") {
      errors.push({
        field: "content",
        message: "content is required and cannot be empty",
        severity: "error",
      });
    }

    // === LENGTH CONSTRAINTS ===
    if (card.title && card.title.length > HUDCARD_CONSTRAINTS.title.maxLength) {
      errors.push({
        field: "title",
        message: `title exceeds max length of ${HUDCARD_CONSTRAINTS.title.maxLength} chars`,
        severity: "error",
      });
    }

    if (
      card.content &&
      card.content.length > HUDCARD_CONSTRAINTS.content.maxLength
    ) {
      errors.push({
        field: "content",
        message: `content exceeds max length of ${HUDCARD_CONSTRAINTS.content.maxLength} chars`,
        severity: "error",
      });
    }

    // === ACTIONS CONSTRAINTS ===
    if (
      card.actions &&
      card.actions.length > HUDCARD_CONSTRAINTS.actions.maxCount
    ) {
      errors.push({
        field: "actions",
        message: `max ${HUDCARD_CONSTRAINTS.actions.maxCount} actions allowed`,
        severity: "error",
      });
    }

    card.actions?.forEach((action, idx) => {
      if (action.label.length > HUDCARD_CONSTRAINTS.actions.labelMaxLength) {
        errors.push({
          field: `actions[${idx}].label`,
          message: `action label exceeds ${HUDCARD_CONSTRAINTS.actions.labelMaxLength} chars`,
          severity: "error",
        });
      }
    });

    // === AUTO-HIDE CONSTRAINTS ===
    if (
      card.autoHideAfterSeconds !== null &&
      card.autoHideAfterSeconds !== undefined
    ) {
      if (
        card.autoHideAfterSeconds < HUDCARD_CONSTRAINTS.autoHide.min ||
        card.autoHideAfterSeconds > HUDCARD_CONSTRAINTS.autoHide.max
      ) {
        warnings.push({
          field: "autoHideAfterSeconds",
          message: `autoHide should be between ${HUDCARD_CONSTRAINTS.autoHide.min}-${HUDCARD_CONSTRAINTS.autoHide.max}s`,
          severity: "warning",
        });
      }
    }

    // === PRIORITY OVERRIDES ===
    if (card.priority && card.priority >= 4) {
      // High priority cards should not auto-hide
      if (card.autoHideAfterSeconds) {
        warnings.push({
          field: "autoHideAfterSeconds",
          message: "autoHide ignored for priority >= 4",
          severity: "warning",
        });
      }

      // High priority cards should not be dismissible
      if (card.dismissible === true) {
        warnings.push({
          field: "dismissible",
          message: "dismissible forced to false for priority >= 4",
          severity: "warning",
        });
      }
    }

    // === METADATA VALIDATION (AR ANCHORING) ===
    if (card.metadata) {
      const { anchorType, worldPosition, worldRotation, autoAnchor, autoAnchorDistance } =
        card.metadata;

      // Validate anchorType
      if (anchorType && anchorType !== "screen-space" && anchorType !== "world-space") {
        errors.push({
          field: "metadata.anchorType",
          message: 'anchorType must be "screen-space" or "world-space"',
          severity: "error",
        });
      }

      // Validate worldPosition
      if (worldPosition !== undefined) {
        if (
          !Array.isArray(worldPosition) ||
          worldPosition.length !== 3 ||
          !worldPosition.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldPosition",
            message: "worldPosition must be [x, y, z] array of 3 numbers",
            severity: "error",
          });
        }

        // Warning if worldPosition provided but anchorType is screen-space
        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.worldPosition",
            message: "worldPosition ignored when anchorType is screen-space",
            severity: "warning",
          });
        }
      }

      // Validate worldRotation
      if (worldRotation !== undefined) {
        if (
          !Array.isArray(worldRotation) ||
          worldRotation.length !== 3 ||
          !worldRotation.every((n) => typeof n === "number")
        ) {
          errors.push({
            field: "metadata.worldRotation",
            message: "worldRotation must be [x, y, z] array of 3 numbers (radians)",
            severity: "error",
          });
        }

        // Warning if worldRotation provided but anchorType is screen-space
        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.worldRotation",
            message: "worldRotation ignored when anchorType is screen-space",
            severity: "warning",
          });
        }
      }

      // Validate autoAnchor
      if (autoAnchor !== undefined) {
        if (autoAnchor !== "face" && autoAnchor !== "surface" && autoAnchor !== "gaze") {
          errors.push({
            field: "metadata.autoAnchor",
            message: 'autoAnchor must be "face", "surface", or "gaze"',
            severity: "error",
          });
        }

        // Warning if autoAnchor used with screen-space
        if (anchorType === "screen-space") {
          warnings.push({
            field: "metadata.autoAnchor",
            message: "autoAnchor ignored when anchorType is screen-space",
            severity: "warning",
          });
        }

        // Warning if both autoAnchor and explicit worldPosition
        if (worldPosition) {
          warnings.push({
            field: "metadata.autoAnchor",
            message: "autoAnchor overrides worldPosition",
            severity: "warning",
          });
        }
      }

      // Validate autoAnchorDistance
      if (autoAnchorDistance !== undefined) {
        if (typeof autoAnchorDistance !== "number" || autoAnchorDistance <= 0) {
          errors.push({
            field: "metadata.autoAnchorDistance",
            message: "autoAnchorDistance must be a positive number (meters)",
            severity: "error",
          });
        }
      }

      // Warning if world-space but no position specified
      if (anchorType === "world-space" && !worldPosition && !autoAnchor) {
        warnings.push({
          field: "metadata",
          message: "world-space card should have worldPosition or autoAnchor",
          severity: "warning",
        });
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validates and sanitizes a card
   * Applies safe defaults and corrections
   */
  sanitize(card: Partial<HUDCard>): HUDCard {
    const sanitized: HUDCard = {
      id: card.id || `card-${Date.now()}`,
      title: (card.title || "Untitled").slice(
        0,
        HUDCARD_CONSTRAINTS.title.maxLength
      ),
      content: (card.content || "").slice(
        0,
        HUDCARD_CONSTRAINTS.content.maxLength
      ),
      variant: card.variant || "neutral",
      priority: card.priority || 3,
      position: card.position || "top-right",
      icon: card.icon || "none",
      autoHideAfterSeconds: card.autoHideAfterSeconds || null,
      dismissible: card.dismissible ?? true,
      actions: (card.actions || []).slice(
        0,
        HUDCARD_CONSTRAINTS.actions.maxCount
      ),
      metadata: card.metadata,
    };

    // Apply priority overrides
    const priority = sanitized.priority ?? 3;
    if (priority >= 4) {
      sanitized.autoHideAfterSeconds = null;
      sanitized.dismissible = false;
    }

    return sanitized;
  }
}
